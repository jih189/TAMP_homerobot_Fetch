<h1>Experience-based Task and Motion Planning Framework for Foliated Manifolds</h>

# Motivation

The objective of this project is to leverage both atlas and Gaussian Mixture Models (GMM) to model the folied manifolds to enhance the performance of task and motion planning in foliated structure problem. In traditional task and motion planning, a two-level planner is commonly employed. Initially, the task planner devises a sequence of tasks, while the subsequent motion planner determines the motion plan for each task in the sequence. Prominent methods such as MTG (Informing Multi-Modal Planning with Synergistic Discrete Leads) and MDP (Multi-Modal Planning on Regrasping for Stable Manipulation) are widely used. Basically, both of them are following the idea of generating a new task sequence which is different from previous failure. However, these methods do not effectively reuse prior planning experiences comming from the motion planner. In this work, we propose a novel framework that leverages the prior planning experiences to model the foliated manifolds more precisely. Therefore, the task planner can generate a more feasible task sequence which contains more information to guide the motion planner.

# Table of Contents
- [Motivation](#motivation)
- [Table of Contents](#table-of-contents)
- [Preivous Works](#preivous-works)
- [Methodology](#methodology)
- [Experimental Goals](#experimental-goals)
- [Foliated planning framework tutorial](#foliated-planning-framework-tutorial)
- [Nautilus tutorial](#nautilus-tutorial)
- [Usage](#usage)
  - [Base tutorial](#base-tutorial)
  - [Evaluation tutorial](#evaluation-tutorial)
- [Other tutorial](#other-tutorial)

# Preivous Works
We have submitted a paper to ICEA 2024(under reviewed) for previous work, here is the [link](https://arxiv.org/pdf/2310.08494.pdf). In this work, we mainly use GMM based Repetitional Roadmap alone to model the foliated manifodls. However, in some cases, when the problem's constrained manifolds' volume are very thin, the previous work will not performace well anymore. <b>Please read this paper if you can!</b>

# Methodology
Baseically, this platform contains two-level planners.

<h2>Task Planner</h2>
Compared to the previous work using only Repetitional Roadmap for the task planner, we will use both Repetitional Roadmap and Atlas here. That is, our task planner contains two level structure to model the foliated manifolds. The first level is to use Repetitional Roadmap as globally guidance, while the second level is to use Atlas as locally guidance.

The modification here is that for each repetitional roadmap's node, we will store the atlas information in it. That is, this atlas will model the local region around this node. Once the task planner returns a task sequence, we will use the atlas information to guide the motion planner instead of using Gaussian Distribution only. One important thing here is that we do not discard the Gaussian Distribution completely. We will still use it when the volume of the constrained manifolds is not thin.


Therefore, each roadmap node should contain following informations:

1. <b>Atlas information</b>: A set of tangent polytopes convers the local region around this node.
2. <b>Gaussion distribution</b>: A distribution to represent the local region around this node. It is used when the volume of the constrained manifolds is not thin. 
3. <b>Collision weight</b>: A scalar value to represent the collision probability of this node. If the value is higher, then the collision probability is higher. Range from 0 to infinity.
4. <b>Constraint violation weight</b>: A scalar value to represent the constraint violation probability of this node. If the value is higher, then the constraint violation probability is higher. Range from 0 to infinity.
5. <b>Atlas-Distribution ratio</b>: A ratio to represent the ratio of atlas and distribution. If the value is higher, then the atlas will be more important. Range from 0 to 1.

The main research here is that, how we should update both <b>Atlas information</b> and <b>Atlas-Distribution ratio</b> based on the previous planning experience.

<h2> Motion Planner</h2>
We will develop CDistributionAtlasRRT as our motion planner. But this planner can read the atlas information, Gaussion Distribution, and atlas-distribution ratio to guide the planning process. The main research here is that, how we should combine those three information to guide the planning process.

# Experimental Goals
In this project, we will compare the following methods in different setup:
1. MTG
2. MTG with Repetitional Roadmap
3. MTG with both Repetitional Roadmap as globally and Atlas as locally.
4. MTG with Repetiaional Roadmap generated by Deep Learning(Optional)

# Foliated planning framework tutorial

The tutorial is in here [foliated manifold framework setup](readme_files/foliation_setup_tutorial.md)

# Nautilus tutorial
Nautilus provides a powerful platform with a lot of resources for us to run training and testing. The tutorial link is [here](readme_files/nautilus_tutorial.md).

<!-- ## Experiments

Here is the list of experiment we will have for this project:

1. pick-and-place with constraint
2. pick-and-place with constraint and regrasping
3. Sliding and regrasping(IROS 2023)
4. Sliding in simple maze

Each experiment here will be saved as a file in directory [experiment_dir](experiment_dir) so later we can load them for testing. Thus, you may need to read the comment in the file to understand how to save and load them. To create the experiment file, you can use the following code:
```
rosrun task_planner create_experiment_[experiment-name].py
``` -->

# Usage

## Base tutorial

In this project, we do not need to run on the real robot, so we can run the move_group in only simulation. Here is the code to launch fake move_group.

```
roslaunch fetch_moveit_config fake_move_group.launch
```
<!-- 
Then you can run the following code for the main pipeline
```
rosrun task_planner main_pipeline.py
``` -->

## Evaluation tutorial
TODO
<!-- We also provide the code to evaluate different task planner. 
```
rosrun task_planner evaluation.py
``` 

This code will first load the experiment file in experiment_dir, then evaluate the performance of each task planner. The evaluation result will be saved in the directory jiaming_manipulation/taskplanner/evaluated_data_dir. You should modify the parameter in the file to change the experiment you want to evaluate and the task planner you want to use. After evaluation, you can visualize them with the following code
```
rosrun task_planner visualize_result.py
```
-->

# Other tutorial
There section contains other tutorials or notes for this project. They are put here for internal use only.

1. [Motion planning tutorial](readme_files/motion_planning_tutorial.md)
2. [Data generation tutorial](readme_files/Data_generation_tutorial.md)